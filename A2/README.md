# А2, анализ merge sort и merge+insertion sort

##
- ФИО: Саватеев Дмитрий Витальевич, БПИ248
- ID посылки по задаче A1i в системе CodeForces: `349242405`
# Экспериментальное исследование гибридной сортировки слиянием

## Описание файлов

- **`a2.cpp`**  
  Cравнение двух алгоритмов сортировки, содержит реализацию:
  - `ArrayGenerator` - генерирует три типа массивов:
    - Случайные значения в диапазоне [0, 6000]
    - Обратно отсортированные массивы
    - Почти отсортированные
  - `SortTester` - проводит временные замеры:
    - 5 прогонов для каждого размера массива (для повышения объективности результатов)
    - Реализует два алгоритма:
      * Стандартный рекурсивный Merge Sort
      * Гибридный Merge+Insertion Sort с порогами перехода [5, 10, 20, 30, 50] элементов

- **`draw_plots.py`**  - строит 7 графиков
      
- **`standard_random.csv`**, **`standard_reversed.csv`**, **`standard_almost_sorted.csv`**, **`hybrid_random.csv`**, **`hybrid_reversed.csv`**, **`hybrid_almost_sorted.csv`** - содержат экспериментальные данные

## Анализ и выводы
1. Преимущество гибридного алгоритма перед обычным в сортировке массивов большого размера заключается в том, что на тех уровнях рекурсии, где массив становится достаточно маленьким для обработки через Merge Sort, сортировка происходит через Insertion Sort. Это оптимально, потому что убирает затраты на рекурсивные вызовы.

2. Ключевым параметром гибридной реализации является порог переключения алгоритмов. В рамках анализа рассматривались 5 конфигураций переключения порогов при размере массива, равном 5, 10, 20, 30, 50. На каждом типе данных был свой лучший порог переключения, но в среднем по трём графикам с результатами работы гибридного алгоритма видно, что оптимальнее всего менять алгоритм при размере массива, равном 20.

3. Как было отмечено в предыдущем пункте, скорость выполнения обоих алгоритмов зависит от типа данных. Самое долгое время работы наблюдается на рандомных (по отсортированности) массивах, а самое быстрое время работы было на массивах, отсортированных в обратном порядке, поскольку на каждом этапе алгоритм разбивает массив пополам и сливает две части одинакового размера, а так как данные расположены строго убывающе, то каждый раз элементы из правой половины практически сразу переходят в результирующий массив, что уменьшает количество сравнений
